#!/usr/bin/env python
#
# A user provides a bare condor submission file, as well as some additional
# cloud scheduler / OpenStack parameters:
# image_uri:    uuid
#                or
#               tenant_name:image_name
# flavor:       hardware profile for the cloud
#
# This script validates these inputs and writes a validated script
# including extra cloud scheduler parameters to stdout.
#
# Bad exit status is set upon failure.

import argparse
import collections
import errno
import keystoneclient.v2_0.client as ksclient
import novaclient.v1_1.client as nclient
import glanceclient.v2.client as glclient
from glanceclient.exc import HTTPConflict
import json
import os
import re
import requests
import sys
import uuid
import logging
#logging.basicConfig()
logging.disable(logging.CRITICAL)

# ID of the batch tenant we need to share with                                 
_BATCH_TENANT_ID = '4267ed6832cd4a1f8d7057142fb36520'

# Parameters that we generate (e.g., from command-line parameters)
# and don't want user to define, along with a message explaining why.
param_disallow = dict(
    [ ['Requirements', 'Generated from image_uri'],
      ['+VMAMI', 'Generated from image_uri'],
      ['+VMInstanceType', 'Generated from flavor'] ] )

# OpenStack auth configuration / defaults.
# Take OS_* variables if provided (with following defaults).
# command-line overrides OS_*
if 'OS_AUTH_URL' not in os.environ:
    os.environ['OS_AUTH_URL'] = 'https://west.cloud.computecanada.ca:5000/v2.0'
if 'OS_USERNAME' not in os.environ and 'USER' in os.environ:
    os.environ['OS_USERNAME'] = os.environ['USER']+'-canfar'

auth = {'username':'',
        'password':'',
        'tenant_name' : '',
        'auth_url':''}

# where to find some common inputs
sharepath = '/usr/local/share/canfar'
canfarcspubkey = sharepath+'/canfarcs_id_rsa.pub'
confscript = sharepath+'/canfar_batch_setup.bash'

# Location for per-user cloud config YAML files. The actual file name
# is a uuid to avoid clashes (since these are user- and job-specific)
try:
    submitter = os.environ['USER']
except:
    print "Error obtaining user name from $USER"
    sys.exit(1)
confdir = '/var/cache/canfar'
conf_yml = '%s/%s_%s.yml' % (confdir,submitter,uuid.uuid4())


# Subroutine to generate a cloud config file. This is copied almost verbatim
# from make_cloud_config, and should be moved to a module at a later point.
def make_cloud_config(inputscript,pubkey,output_yml,
                      image_name=None,
                      submitter=None):
    # Generate a cloud config file (YAML) that performs the following
    # operations:
    # - mount an ephemeral partition
    # - inject a public ssh key into the generic user account
    # - write and execute the cloud scheduler configuration script
    #
    # Note: This needs to be compatible with cloud-init 0.6.3, which means
    #       no "write_files" module (hence multi-line cat shenanigans in
    #       runcmd to get the configuration script into the VM and execute
    #       it)
    # - image_name and submitter are used by canfar_batch_setup.bash to
    #   set the VMType. If not specified defaults to $HOSTNAME and $USER 

    # the full output path name of the configuration script when copied
    # into the VM
    outputscript = '/tmp/' + os.path.basename(inputscript)

    # load script content
    script_content_raw = open(inputscript,'r').readlines()
    script_content = "".join("      "+l for l in script_content_raw)

    # load canfarcs pubkey
    pubkey_content = open(pubkey,'r').read().strip()

    # obtain the mount point for the ephemeral partition from the script
    ephemeral_dir = re.search("EPHEMERAL_DIR\s*=\s*[\'\"]([^\'\"]+)",
                              script_content).group(1)

    start_text = '''#cloud-config
# DO NOT EDIT THIS FILE: generated by canfar_job_validate

ssh_authorized_keys:
  - %s

# Normally wouldn't bother with arguments beyond /ephemeral,
# but defaults didn't work with SL5
mounts:
  - [ ephemeral0, %s, auto, defaults, 0, 0 ]

runcmd:
  - |
      cat - > %s <<'EOF'
''' % (pubkey_content,ephemeral_dir,outputscript)

    script_arguments = ", '--update-cloud-scheduler'"
    if image_name:
        script_arguments = script_arguments + \
                           ", '--vm-image-name=\"%s\"'" % image_name
    if submitter:
        script_arguments = script_arguments + \
                           ", '--submitter=\"%s\"'" % submitter

    end_text = '''
      EOF
  - [ 'chmod', '0755', '%s' ]
  - [ '%s'%s ]
''' % (outputscript,outputscript,script_arguments)

    f = open(output_yml,'w')
    f.write(start_text)
    f.write(script_content)
    f.write(end_text)
    f.close()


# --- ENTRYPOINT --------------------------------------------------------------

try:
    # Parse command line
    description = \
    '''Create a validated CANFAR submission file (written to stdout) based on
    a Condor job description file and other user inputs.
    '''
    parser = argparse.ArgumentParser(description=description)

    parser.add_argument('jobfile',help='Condor job description file')
    parser.add_argument('image_uri',help="VM image for job. Valid forms: 'image_uuid' or 'tenant_name:image_name' (this image tenant_name need not match --tenant_name)")
    parser.add_argument('flavor',help='a valid hardware flavor')
    parser.add_argument('--os-username',help='user name if OS_USERNAME not set')
    parser.add_argument('--os-password',help='password if OS_PASSWORD not set')
    parser.add_argument('--os-tenant-name',
                        help='tenant name if OS_TENANT_NAME not set (for authentication only; not required)')
    parser.add_argument('--os-auth-url',help='auth URL if OS_AUTH_URL not set')

    parser.add_argument('-v','--verbose',default=False,
                        help='verbose output',action='store_true')

    args,extra_args = parser.parse_known_args()

    # Obtain auth parameters from command-line / environment
    for key in auth:
        argname = 'os_'+key
        osvar = argname.upper()
        if eval( 'args.'+argname ):
            auth[key] = eval( 'args.'+argname )
        elif osvar in os.environ:
            auth[key] = os.environ[osvar]
        elif key == 'tenant_name':
            # If not set by user we will discover a tenant ourselves
            pass
        else:
            raise Exception("Neither --%s nor %s set in the environment" \
                % (argname.replace('_','-'), osvar))

    jobfile = args.jobfile
    image_uri = args.image_uri
    flavor = args.flavor

    if args.verbose:
        print "auth_url: %s\nusername: %s\npassword: HIDDEN\ntenant_name: %s\njobfile: %s" % \
            (auth['auth_url'],auth['username'],auth['tenant_name'] or 'NOT SET',
             jobfile)

    # Check for required parameters in jobfile
    try:
        jobfile_data = open(jobfile,'r').read()
    except:
        raise Exception("Could not read the contents of "+jobfile)

    for param in param_disallow:
        par_regex = param
        if param[0] == '+':
            # Parameters that start with + need to be escaped in regex
            par_regex = '\\'+par_regex
        regex = "^[^#]*"+par_regex+"\s*=.*$"
        match = re.findall(regex,jobfile_data,re.MULTILINE)

        if match:
            msg = "jobfile should not contain parameter '%s':\n%s" \
                  % (param, param_disallow[param])
            raise Exception(msg)

    # This keystone client is a convenient way to get a
    # non-tenant-scoped token.
    k_nt = ksclient.Client(username=auth['username'],
                           password=auth['password'],
                           auth_url=auth['auth_url'])

    # Obtain a list of all tenants the user belongs to.  We are going
    # to use REST API directly as Python libraries don't expose all
    # functionality we need.
    token = k_nt.auth_token
    headers = {'X-Auth-Token': token }
    tenant_url = auth['auth_url']+'/tenants'
    r = requests.get(tenant_url, headers=headers)
    tenant_data = r.json()

    # Take first tenant for auth purposes if none specified
    if not auth['tenant_name']:
        if len(tenant_data['tenants']) > 0:
            tenant = tenant_data['tenants'][0]
            auth['tenant_name'] = tenant['name']
            if args.verbose:
                print "No tenant_id specified, so choosing %s" \
                    % auth['tenant_name']
        else:
            raise Exception('Unable to discover tenant_name. Please set')

    # Now get a tenant-scoped keystone client, and obtain the glance_endpoint
    k = ksclient.Client(username=auth['username'],
                        password=auth['password'],
                        tenant_name=auth['tenant_name'],
                        auth_url=auth['auth_url'])
    glance_endpoint = k.service_catalog.url_for(service_type='image')

    # parse image_uri and try to identify/verify its uuid
    try:
        # user provided uuid 
        image_uuid = str(uuid.UUID(image_uri))

        # Loop over all tenants to find that image
        matches = []
        
        for tenant in tenant_data['tenants']:
            if args.verbose:
                print "Searching tenant %s: %s" % (tenant['name'],tenant['id'])

            # Get a keystone/glance clients scoped to this tenant              
            k = ksclient.Client(username=auth['username'],
                                password=auth['password'],
                                tenant_name=tenant['name'],
                                auth_url=auth['auth_url'])
            glance = glclient.Client(glance_endpoint, token=k.auth_token)

            for i in glance.images.list():
                if image_uuid == i['id']:
                    image_name = i['name']
                    image_tenant_name = tenant['name']

        if not image_tenant_name:
            raise Exception("Could not locate tenant for image uuid '%s'" \
                            % image_uuid)

    except ValueError:
        try:
            # see if we have tenant_name:image_name
            (image_tenant_name,image_name) = image_uri.split(':',1)
        except:
            raise Exception("image_uri '%s' is badly formed" % image_uri) 

        # Now look for a unique match to supplied image name
        try:
            k = ksclient.Client(username=auth['username'],
                                password=auth['password'],
                                tenant_name=image_tenant_name,
                                auth_url=auth['auth_url'])
            glance = glclient.Client(glance_endpoint, token=k.auth_token)
        except Exception as E:
            raise Exception("Couldn't authenticate to tenant '%s': " % image_tenant_name + \
                            str(E))

        matches = []
        for glanceimage in glance.images.list():
            if glanceimage['name'] == image_name:
                matches.append(glanceimage['id'])

        if len(matches) == 0:
            raise Exception("Couldn't find image named '%s'" % image_name)
        elif len(matches) > 1:
            errstr="Multiple image UUIDs in tenant '%s' match image name '%s':\n%s"\
                % (image_tenant_name, image_name, '\n'.join(matches))
            raise Exception(errstr)

        # unique image_uuid
        image_uuid = matches[0]

        if args.verbose:
            print "image_uuid: %s" % image_uuid

    # Share the image with batch tenant. First we need to ensure that we
    # have a glance client scoped to the correct tenant of the image.
    if args.verbose:
        print "sharing image uuid '%s' from tenant '%s' with batch tenant" % \
            (image_uuid,image_tenant_name)
    k = ksclient.Client(username=auth['username'],
                        password=auth['password'],
                        tenant_name=image_tenant_name,
                        auth_url=auth['auth_url'])
    glance = glclient.Client(glance_endpoint, token=k.auth_token)
    try:
        glance.image_members.create(image_uuid,_BATCH_TENANT_ID)
    except HTTPConflict as E:
        if E.code == 409:
            if args.verbose:
                print "Image already shared."
            pass
        else:
            raise E


    # Check for a valid flavor
    nova = nclient.Client(auth['username'], auth['password'],
                          auth['tenant_name'], auth['auth_url'])

    flavors = nova.flavors.list()
    #good_flavors = []
    #bad_flavors = []
    #for f in flavors:
    #    if f.ephemeral:
    #        good_flavors.append(f.name)
    #    else:
    #        bad_flavors.append(f.name)
    #if not good_flavors:
    #    raise Exception("Error: cloud does not offer flavors with ephemeral partition!")

    #if flavor not in good_flavors:

    flavor_names = [f.name for f in flavors]
    if flavor not in flavor_names:
        msg = "Supplied flavor '%s' is not valid. Must be one of:\n"\
              % flavor
        msg = msg + ', '.join(flavor_names)
        raise Exception(msg)

    # generate cloud config file for this user
    try:
        # Make the directory for the file if not already there
        os.makedirs(confdir)
    except OSError as exc: # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(confdir):
            pass
    else:
        raise

    if args.verbose:
        print "Generating cloud config script (YAML) with:"
        print "canfarcs pubkey     = %s" % canfarcspubkey
        print "config shell script = %s" % confscript
        print "image_name          = %s" % image_name
        print "submitter           = %s" % submitter
        print "output YAML         = %s" % conf_yml

    vmtype = '%s:%s'%(image_tenant_name,image_name)

    make_cloud_config(confscript,canfarcspubkey,conf_yml,
                      image_name=vmtype,
                      submitter=submitter)

except Exception as E:
    print "ERROR:",E
    sys.exit(1)

jobfile = '''Requirements = VMType =?= "%s" && Arch == "x86_64"
+VMAMI          = "canfar:%s"
+VMInstanceType = "canfar:%s"
+VMAMIConfig    = "%s"
''' % (vmtype,image_uuid,flavor,conf_yml) + jobfile_data

print jobfile

sys.exit(0)
