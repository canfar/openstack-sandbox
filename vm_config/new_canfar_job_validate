#!/usr/bin/env python
#
# A user provides a bare condor job description file, as well as image
# and flavor IDs.
#
# This script validates these inputs and writes an augmented condor
# job file including extra cloud scheduler parameters to stdout, and also
# generates a cloud-config script that cloud scheduler will use to
# configure running instances of the VM to work with Condor.
#
# Bad exit status is set upon failure.

import argparse
import errno
import keystoneclient.v2_0.client as ksclient
from keystoneclient.apiclient import exceptions as keystone_exceptions
import glanceclient.v2.client as glclient
from glanceclient.exc import HTTPConflict
import os
import re
import requests
import sys
import uuid
import logging
#logging.basicConfig()
logging.disable(logging.CRITICAL)

# Parameters that we generate (e.g., from command-line parameters)
# and don't want user to define, along with a message explaining why.
param_disallow = dict(
    [ ['Requirements', 'Generated from image'],
      ['+VMAMI', 'Generated from image'],
      ['+VMInstanceType', 'Generated from flavor'] ] )

# OpenStack auth configuration / defaults.
# Take OS_* variables if provided (with following defaults).
# command-line overrides OS_*
if 'OS_AUTH_URL' not in os.environ:
    os.environ['OS_AUTH_URL'] = 'https://west.cloud.computecanada.ca:5000/v2.0'
if 'OS_USERNAME' not in os.environ and 'USER' in os.environ:
    os.environ['OS_USERNAME'] = os.environ['USER']+'-canfar'

auth = {'username':'',
        'password':'',
        'tenant_name' : '',
        'auth_url':''}

# where to find some common inputs
sharepath = '/usr/local/share/canfar'
canfarcspubkey = sharepath+'/canfarcs_id_rsa.pub'
confscript = sharepath+'/canfar_batch_setup.bash'

# Location for per-user cloud config YAML files. The actual file name
# is a uuid to avoid clashes (since these are user- and job-specific)
confdir = '/var/cache/canfar'

# Subroutine to generate a cloud config file. This is copied almost verbatim
# from make_cloud_config, and should be moved to a module at a later point.
def make_cloud_config(inputscript,pubkey,output_yml,submitter,
                      image_name=None):
    # Generate a cloud config file (YAML) that performs the following
    # operations:
    # - mount an ephemeral partition
    # - inject a public ssh key into the generic user account
    # - write and execute the cloud scheduler configuration script
    #
    # Note: This needs to be compatible with cloud-init 0.6.3, which means
    #       no "write_files" module (hence multi-line cat shenanigans in
    #       runcmd to get the configuration script into the VM and execute
    #       it)
    # - image_name and submitter are used by canfar_batch_setup.bash to
    #   set the VMType. If not specified defaults to $HOSTNAME and $USER 

    # the full output path name of the configuration script when copied
    # into the VM
    outputscript = '/tmp/' + os.path.basename(inputscript)

    # load script content
    script_content_raw = open(inputscript,'r').readlines()
    script_content = "".join("      "+l for l in script_content_raw)

    # load canfarcs pubkey
    pubkey_content = open(pubkey,'r').read().strip()

    # obtain the mount point for the ephemeral partition from the script
    ephemeral_dir = re.search("EPHEMERAL_DIR\s*=\s*[\'\"]([^\'\"]+)",
                              script_content).group(1)

    start_text = '''#cloud-config
# DO NOT EDIT THIS FILE: generated by canfar_job_validate

ssh_authorized_keys:
  - %s

# Normally wouldn't bother with arguments beyond /ephemeral,
# but defaults didn't work with SL5
mounts:
  - [ ephemeral0, %s, auto, defaults, 0, 0 ]

runcmd:
  - |
      cat - > %s <<'EOF'
''' % (pubkey_content,ephemeral_dir,outputscript)

    script_arguments = ", '--update-cloud-scheduler'"
    if image_name:
        script_arguments = script_arguments + \
                           ", '--vm-image-name=\"%s\"'" % image_name
    if submitter:
        script_arguments = script_arguments + \
                           ", '--submitter=\"%s\"'" % submitter

    end_text = '''
      EOF
  - [ 'chmod', '0755', '%s' ]
  - [ '%s'%s ]
''' % (outputscript,outputscript,script_arguments)

    f = open(output_yml,'w')
    f.write(start_text)
    f.write(script_content)
    f.write(end_text)
    f.close()


# --- ENTRYPOINT --------------------------------------------------------------

try:
    # Parse command line
    description = \
    '''Create a validated CANFAR submission file (written to stdout), and a
    customized cloud-config YAML file (in %s), based on a Condor job
    description file, job execution script, image, and flavor.
    ''' % confdir
    parser = argparse.ArgumentParser(description=description)

    parser.add_argument('jobfile',help='Condor job description file')
    parser.add_argument('jobscript',help='Condor job execution script')
    parser.add_argument('image_id',help='VM image ID for job')
    parser.add_argument('flavor_id',help='hardware flavor ID')
    parser.add_argument('--os-username',
                        help='user name if OS_USERNAME not set')
    parser.add_argument('--os-password',help='password if OS_PASSWORD not set')
    parser.add_argument('--os-tenant-name',
                        help='tenant name if OS_TENANT_NAME not set')
    parser.add_argument('--os-auth-url',help='auth URL if OS_AUTH_URL not set')
    parser.add_argument('--submitter',
                        help='Set submitter for YAML (default $USER)')
    parser.add_argument('-v','--verbose',default=False,
                        help='verbose output',action='store_true')

    args = parser.parse_args()

    # Obtain auth parameters from command-line / environment
    for key in auth:
        argname = 'os_'+key
        osvar = argname.upper()
        if eval( 'args.'+argname ):
            auth[key] = eval( 'args.'+argname )
        elif osvar in os.environ:
            auth[key] = os.environ[osvar]
        else:
            raise Exception("Neither --%s nor %s set in the environment" \
                % (argname.replace('_','-'), osvar))

    if args.submitter:
        submitter = args.submitter
    else:
        try:
            submitter = os.environ['USER']
        except:
            print "Error obtaining user name from $USER"
            sys.exit(1)
    conf_yml = '%s/%s_%s.yml' % (confdir,submitter,uuid.uuid4())

    jobfile = args.jobfile
    jobscript = args.jobscript

    # check for valid UUIDs
    try:
        image_id = str(uuid.UUID(args.image_id))
    except:
        raise Exception("image_id '%s' is not a valid UUID" % args.image_id)
    try:
        flavor_id = str(uuid.UUID(args.flavor_id))
    except:
        raise Exception("flavor_id '%s' is not a valid UUID" % args.flavor_id)

    if args.verbose:
        print \
'''auth_url: %s
username: %s
password: HIDDEN
tenant_name: %s
jobfile: %s
image_id: %s
flavor_id: %s''' % (auth['auth_url'],auth['username'],auth['tenant_name'],
                    jobfile, image_id, flavor_id)


    # Check parameters in jobfile
    try:
        jobfile_data = open(jobfile,'r').read()
    except:
        raise Exception("Could not read the contents of "+jobfile)

    for param in param_disallow:
        par_regex = param
        if param[0] == '+':
            # Parameters that start with + need to be escaped in regex
            par_regex = '\\'+par_regex
        regex = "^[^#]*"+par_regex+"\s*=.*$"
        match = re.findall(regex,jobfile_data,re.MULTILINE)

        if match:
            msg = "jobfile should not contain parameter '%s'. Reason: %s" \
                  % (param, param_disallow[param])
            raise Exception(msg)

    # Re-write 'Executable' line since the proc web service will have
    # placed it somewhere different from the user's original location
    if not os.path.isfile(jobscript):
        raise Exception("jobscript '%s' does not exist" % jobscript)

    jobfile_data =  re.sub('^\s*Executable\s*=\s*(.*)$',
                           'Executable = %s' % jobscript,
                           jobfile_data,flags=re.MULTILINE)

    # determine the name of the image from its UUID, and the name
    # of the tenant that owns it. First we get a glance client to
    # get the name of the given image ID. We then query that image's
    # metadata to obtain its owner tenant id. Finally, we use a second
    # keystone client scoped to the image's owner tenant to obtain
    # its tenant name
    k = ksclient.Client(username=auth['username'],
                        password=auth['password'],
                        tenant_name=auth['tenant_name'],
                        auth_url=auth['auth_url'])
    glance_endpoint = k.service_catalog.url_for(service_type='image')
    g = glclient.Client(glance_endpoint, token=k.auth_token)
    i = g.images.get(image_id)
    image_name = i['name']
    tenant_id = i['owner']

    k_image = ksclient.Client(username=auth['username'],
                              password=auth['password'],
                              tenant_id=tenant_id,
                              auth_url=auth['auth_url'])
    image_tenant_name = k_image.tenant_name

    # generate cloud config file for this user
    try:
        # Make the directory for the file if not already there
        os.makedirs(confdir)
    except OSError as exc: # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(confdir):
            pass
    else:
        raise

    if args.verbose:
        print "Generating cloud config script (YAML) with:"
        print "canfarcs pubkey     = %s" % canfarcspubkey
        print "config shell script = %s" % confscript
        print "image_name          = %s" % image_name
        print "image_tenant_name   = %s" % image_tenant_name
        print "submitter           = %s" % submitter
        print "output YAML         = %s" % conf_yml

    vmtype = '%s:%s'%(image_tenant_name,image_name)

    make_cloud_config(confscript,canfarcspubkey,conf_yml,submitter,
                      image_name=vmtype)

except Exception as E:
    print "ERROR:",E
    if isinstance(E, keystone_exceptions.Unauthorized):
        print "Did you source a valid openrc file? (i.e., are OS_* environment variables set?)\n" + \
            "Check for errors in your credentials."
    sys.exit(1)

jobfile = '''Requirements = VMType =?= "%s" && Arch == "x86_64"
+VMAMI          = "canfar:%s"
+VMInstanceType = "canfar:%s"
+VMAMIConfig    = "%s"
+VMKeepAlive    = 5
''' % (vmtype,image_id,flavor_id,conf_yml) + jobfile_data

if args.verbose:
    print "---BEGIN JOBFILE---------------------------------------------------------------"

print jobfile

sys.exit(0)
