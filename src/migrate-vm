#!/usr/bin/env python

import sys
import os
import guestfs
import argparse
import re
import traceback

# Dictionary of known OS types (keys), and type strings (values) that
# will be used to pattern match the product name string
valid_os_type = { "sl5" : "Scientific Linux release 5",
                  "sl6" : "Scientific Linux release 6",
                  "ub12" : "Ubuntu 12.04",
                  "ub13" : "Ubuntu 13.10" }

# parse command line
parser = argparse.ArgumentParser(description='Migrate old Xen-style CANFAR VMs for compatibility with OpenStack/KVM')
parser.add_argument('--inputimage', required=True, help='Input VM image')
parser.add_argument('--outputimage', required=True,
                    help='Converted output VM image')
args = parser.parse_args()

# Check pre-requisites
# Reference:
#   http://rwmj.wordpress.com/2013/04/04/new-in-libguestfs-use-syslinux-or-extlinux-to-make-bootable-guests/)
try:
    # First get size and make a sparse output image
    print "Try making a sparse output image %s..." % (args.outputimage)

    # Note that we tack on 4096 sectors * 512 bytes/sector to leave
    # some extra space for the partitioning in the 'part_add' call below
    size = os.path.getsize(args.inputimage) + 512 * 4096
    f = open(args.outputimage,'ab')
    f.truncate(size)
    f.close()
except:
    traceback.print_exc(file=sys.stdout)
    print "FAILED: couldn't create output image %s" % (args.outputimage)
    sys.exit(1)

# create a guestfs handle, add the input and output images, and run
# the guestfs back-end
try:
    print "Try opening %s read-only, and %s for write..." \
        % (args.inputimage, args.outputimage)
    g = guestfs.GuestFS(python_return_dict=True)
    g.add_drive_opts(args.inputimage, format="raw", readonly=True)
    g.add_drive_opts(args.outputimage, format="raw", readonly=False)

    # After the following the input image will be /dev/sda, and the
    # output image /dev/sdb
    g.launch()
except:
    traceback.print_exc(file=sys.stdout)
    print "FAILED: perhaps you need to run this script with root privileges?"
    sys.exit(1)


# Check for extlinux and load in mbr.bin
print "Checking for extlinux and loading mbr.bin..."

try:
    if not g.feature_available(['extlinux']):
        raise Exception("libguestfs can't find extlinux")

    mbr = "/usr/share/extlinux/mbr.bin"
    if not os.path.isfile(mbr):
        mbr = "/usr/lib/extlinux/mbr.bin"
        if not os.path.isfile(mbr):
            raise Exception("Couldn't locate mbr.bin")

    f = open(mbr, 'rb')
    mbr_data = f.read()
    f.close()

    if len(mbr_data) != 440:
        raise "%s should have a length of 440 bytes" % (mbr)
except:
    traceback.print_exc(file=sys.stdout)
    print "FAILED: problem with extlinux. Have you installed it? correctly?"
    sys.exit(1)

# Figure out which OS type is installed on the image. Assume only 1 root.
try:
    print "Identifying the operating system..."
    roots = g.inspect_os()
    root = roots[0]
    print "Found root %s" % (root)
    product_name = g.inspect_get_product_name(root)
    print product_name

    os_type = None
    for check_type in valid_os_type:
        if re.search(valid_os_type[check_type],product_name):
            os_type=check_type
            continue

    if os_type is None:
        raise Exception("Product name could not be converted to a known OS")

except:
    traceback.print_exc(file=sys.stdout)
    print "FAILED: couldn't find a known OS."
    sys.exit(1)

print "*** We are working with an %s image." % (os_type)

# Create a new partitioned version of the VM.
#partitions = g.list_partitions()
#if root not in partitions:
try:
    print "Initializing the partition in %s..." % (args.outputimage)
    g.part_init('/dev/sdb', 'mbr')
    g.part_add('/dev/sdb', 'p', 2048, -2048)

    print "Copying data to the partition..."
    g.copy_device_to_device(root, '/dev/sdb1', sparse=True)

except:
    traceback.print_exc(file=sys.stdout)
    print "FAILED: Couldn't copy to %s. Perhaps it is too small?" % \
        (args.outputimage)
    sys.exit(1)
